








import React, { useState, ChangeEvent, FormEvent } from 'react';
import axios from 'axios';
import { useRouter } from 'next/router';
import toast, { Toaster } from 'react-hot-toast';
import Cookies from 'js-cookie';

export default function Paginas() {
  const [isRegistering, setIsRegistering] = useState(true);
  const [formData, setFormData] = useState({
    userName: '',
    correo: '',
    contrasena: '',
  });
  const router = useRouter();

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData((prevFormData) => ({
      ...prevFormData,
      [name]: value,
    }));
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    if (isRegistering) {
      try {
        const response = await axios.post('/api/inicio-sesionUsuario/register', formData);
        toast.success('Registro exitoso');
      } catch (error) {
        toast.error('Error en el registro');
      }
    } else {
      try {
        const response = await axios.post('/api/inicio-sesionUsuario/auth', {
          identificador: formData.correo,
          contrasena: formData.contrasena,
        });
        const { token } = response.data;
        Cookies.set('token', token); // Guarda el token en las cookies

        toast.success('Inicio de sesión exitoso');
        console.log('Login successful:', response.data);

        // Redirige al usuario según su rol
        const userResponse = await axios.get('/api/inicio-sesionUsuario/auth', {
          headers: { Authorization: `Bearer ${token}` },
        });
        Cookies.set('id', userResponse.data.id);
        Cookies.set('userName', userResponse.data.userName);
        Cookies.set('correo', userResponse.data.correo);
        Cookies.set('contrasena', userResponse.data.contrasena);
        Cookies.set('rol', userResponse.data.rol);
        const { rol } = userResponse.data;

        if (rol === 'Estudiante') {
          router.push('/Paginas/Estudiante');
        } else if (rol === 'Profesor') {
          router.push('/Paginas/Profesor');
        } else {
          toast.error('Rol de usuario desconocido');
        }
      } catch (error) {
        console.error('No se pudo iniciar sesión:', error);
        toast.error('Error en el inicio de sesión');
      }
    }
  };

  const toggleMode = () => {
    setIsRegistering(!isRegistering);
  };

  return (
    <div className='mt-10 sm:mx-auto sm:w-full sm:max-w-sm flex min-h-full flex-col justify-center px-6 py-8 lg:px-8 block w-full rounded-md border-0 py-1.5 bg-sky-50 shadow-2xl'>
      <h1 className='sm:mx-auto sm:w-full sm:max-w-sm text-black mb-5 not-italic text-2xl text-center'>{isRegistering ? 'Registro' : 'Inicio de Sesión'}</h1>
      <form onSubmit={handleSubmit} method="POST" className='space-y-6'>
        {isRegistering && (
          <input
            className='block w-full rounded-md border-0 py-1.5 p-3 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6 text-left'
            type="text"
            name="userName"
            value={formData.userName}
            onChange={handleChange}
            placeholder="Nombre de usuario"
            required
          />
        )}
        <input
          className='block w-full rounded-md border-0 py-1.5 p-3 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6'
          type="text"
          name="correo"
          value={formData.correo}
          onChange={handleChange}
          placeholder={isRegistering ? "Correo" : "Correo o User Name"}
          required
        />
        <input
          className='block w-full rounded-md border-0 py-1.5 p-3 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6'
          type="password"
          name="contrasena"
          value={formData.contrasena}
          onChange={handleChange}
          placeholder="Contraseña"
          required
        />
        <div className='flex justify-center'>
          <button type="submit" className='text-center text-black bg-indigo-300 p-2 py-2 px-5 rounded-lg'>{isRegistering ? 'Registrar' : 'Iniciar'}</button>
        </div>
      </form>
      <button onClick={toggleMode} className='text-center text-black underline p-3'>
        {isRegistering ? 'Inicio de Sesión' : 'Registro'}
      </button>
      <Toaster />
    </div>
  );
}




import Paginas from "./Paginas";


export default function Home() {
  return (
    <main className="bg-gradient-to-r from-fuchsia-500 to-cyan-500 min-h-screen flex items-center justify-center">
      <div className="">
      <Paginas />
      </div>
    </main>
  );
}



import { Html, Head, Main, NextScript } from "next/document";

export default function Document() {
  return (
    <Html lang="en">
      <Head />
      <body className="bg-white m-0 p-0 min-h-screen w-full">
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}


// pages/api/usuario/auth.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { compare } from 'bcryptjs';
import { sign, verify } from 'jsonwebtoken';
import { db } from '../../../lib/lib';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (!process.env.JWT_SECRET) {
    return res.status(500).json({ error: 'JWT_SECRET not defined' });
  }

  const JWT_SECRET = process.env.JWT_SECRET;

  if (req.method === 'POST') {
    const { identificador, contrasena } = req.body;

    try {
      let user = await db.usuario.findFirst({
        where: {
          OR: [
            { correo: identificador },
            { userName: identificador },
          ],
        },
      });

      if (!user) {
        return res.status(401).json({ error: 'Invalid credentials' });
      }

      const passwordMatch = await compare(contrasena, user.contrasena);

      if (!passwordMatch) {
        return res.status(401).json({ error: 'Invalid credentials' });
      }

      const token = sign({ userId: user.id }, JWT_SECRET, {
        expiresIn: '1h',
      });

      res.status(200).json({ token });
    } catch (error) {
      console.error('Login failed:', error);
      res.status(500).json({ error: 'Login failed' });
    }
  } else if (req.method === 'GET') {
    const token = req.headers.authorization?.split(' ')[1];

    if (!token) {
      return res.status(401).json({ error: 'Token not provided' });
    }

    try {
      const decoded = verify(token, JWT_SECRET) as { userId: number };
      const user = await db.usuario.findUnique({ where: { id: decoded.userId } });

      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }

      res.status(200).json(user);
    } catch (error) {
      res.status(500).json({ error: 'Failed to fetch user' });
    }
  } else {
    res.status(405).json({ error: 'Method not allowed' });
  }
}



// pages/api/auth/register.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { hash } from 'bcryptjs';
import {db} from '../../../lib/lib';


export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method === 'POST') {
        const { userName, correo, contrasena } = req.body;

        const hashedPassword = await hash(contrasena, 10);

        try {
        const user = await db.usuario.create({
            data: {
                rol: "Estudiante",
                userName,
                correo,
                contrasena: hashedPassword,
            },
        });
        res.status(201).json(user);
        } catch (error) {
        res.status(500).json({ error: 'User creation failed'});
        }
    } else {
        res.status(405).json({ error: 'Method not allowed' });
    }     
}






/pages/api/usuario/index.js
javascript
Copiar código
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default async function handler(req, res) {
  const { method } = req;

  switch (method) {
    case 'GET':
      // Fetch all users
      const usuarios = await prisma.usuario.findMany({
        include: { ProductosVender: true, Comentarios: true },
      });
      res.status(200).json(usuarios);
      break;

    case 'POST':
      // Create a new user
      const { nombre, apellido, email, numero, rol } = req.body;
      const newUsuario = await prisma.usuario.create({
        data: { nombre, apellido, email, numero, rol },
      });
      res.status(201).json(newUsuario);
      break;

    default:
      res.setHeader('Allow', ['GET', 'POST']);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}
/pages/api/productoVender/index.js
javascript
Copiar código
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default async function handler(req, res) {
  const { method } = req;

  switch (method) {
    case 'GET':
      // Fetch all products for sale
      const productos = await prisma.productoVender.findMany({
        include: { ProductoComprado: true, UsuarioVendedor: true },
      });
      res.status(200).json(productos);
      break;

    case 'POST':
      // Create a new product for sale
      const { nombreServicio, idUsuarioVendedor } = req.body;
      const newProducto = await prisma.productoVender.create({
        data: { nombreServicio, idUsuarioVendedor },
      });
      res.status(201).json(newProducto);
      break;

    default:
      res.setHeader('Allow', ['GET', 'POST']);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}
/pages/api/productoComprado/index.js
javascript
Copiar código
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default async function handler(req, res) {
  const { method } = req;

  switch (method) {
    case 'GET':
      // Fetch all purchased products
      const productos = await prisma.productoComprado.findMany({
        include: { ProductoVender: true, Comentarios: true },
      });
      res.status(200).json(productos);
      break;

    case 'POST':
      // Create a new purchased product
      const { idProductoVender, calificacion } = req.body;
      const newProductoComprado = await prisma.productoComprado.create({
        data: { idProductoVender, calificacion },
      });
      res.status(201).json(newProductoComprado);
      break;

    default:
      res.setHeader('Allow', ['GET', 'POST']);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}
/pages/api/comentario/index.js
javascript
Copiar código
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default async function handler(req, res) {
  const { method } = req;

  switch (method) {
    case 'GET':
      // Fetch all comments
      const comentarios = await prisma.comentario.findMany({
        include: { Usuario: true, ProductoComprado: true },
      });
      res.status(200).json(comentarios);
      break;

    case 'POST':
      // Create a new comment
      const { contenido, idUsuario, idProductoComprado } = req.body;
      const newComentario = await prisma.comentario.create({
        data: { contenido, idUsuario, idProductoComprado },
      });
      res.status(201).json(newComentario);
      break;

    default:
      res.setHeader('Allow', ['GET', 'POST']);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}
These examples demonstrate how to handle GET and POST requests for each model. You can extend these handlers to include PUT and DELETE requests for updating and deleting records, respectively.